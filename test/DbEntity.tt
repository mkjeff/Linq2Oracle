<#@ output extension=".cs" encoding="UNICODE" #>
<#@ assembly name="mscorlib.dll" #>
<#@ assembly name="System.Core.dll" #>
<#@ assembly name="System.Xml.dll" #>
<#@ assembly name="System.Data.dll" #>
<#@ assembly name="Oracle.ManagedDataAccess" #>
<#@ assembly name="System.Data.DataSetExtensions.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="Oracle.ManagedDataAccess.Client" #>
<#@ template language="C#v4.0" debug="True" #>
using System;
using System.Diagnostics;
using System.Text;
using Oracle.ManagedDataAccess.Client;
using Linq2Oracle;
using Linq2Oracle.Expressions;
namespace Test.DataModel {
<# 
foreach(var db in new[] {
		new{ ConnectionString = @"User Id=username;Password=passwd;data source=//server:port/SID" , Schema="schema"},
}){
using (var con = new OracleConnection(db.ConnectionString)) {
	// Customize.If you need enum type mapping.
	var enumTypeMap = new Dictionary<string,Type>();
	//var enumTypeMap = (from asm in AppDomain.CurrentDomain.GetAssemblies()
    //                   from type in asm.GetExportedTypes()
    //                   where type.IsEnum
    //                   from attr in (DbTypeAttribute[])type.GetCustomAttributes(typeof(DbTypeAttribute), false)
    //                   select new {
    //                       Key = attr.TableName + "." + attr.ColumnName,
    //                       Type = type
    //                   }).ToDictionary(c => c.Key, c => c.Type);

    con.Open();
    
    //System.Diagnostics.Debugger.Break();
    var res = new[] { db.Schema };
	var alltables = con.GetSchema("Tables", res);
    var columns = con.GetSchema("Columns", res);
    var pks = con.GetSchema("PrimaryKeys", res);
    var indexs = con.GetSchema("IndexColumns", res);
	var views = con.GetSchema("Views",res);
    var tables = (from column in columns.AsEnumerable()
				  where alltables.AsEnumerable().Any(r=>r.Field<string>("table_name")== column.Field<string>("table_name"))
					||  views.AsEnumerable().Any(r=>r.Field<string>("view_name")==column.Field<string>("table_name"))
                  group column by column.Field<string>("table_name") into tableColumns
                  select new {
                      TableName =  tableColumns.Key,
					  EntityName = tableColumns.Key,
                      Columns = (from c in tableColumns
                                 let ColumnName = c.Field<string>("column_name")
                                 let DataType = c.Field<string>("datatype")
                                 let IsNullable = c.Field<string>("nullable") == "Y"
                                 let Length = c.Field<decimal>("length")
                                 let Precision = c.Field<decimal?>("precision")
                                 let Scale = c.Field<decimal?>("scale")
								 orderby ColumnName
								 select new {
                                    IsPrimaryKey = (from idx in indexs.AsEnumerable()
                                                    where idx.Field<string>("table_name") == tableColumns.Key
                                                       && idx.Field<string>("column_name") == ColumnName
                                                    from pk in pks.AsEnumerable()
                                                    where pk.Field<string>("index_name") == idx.Field<string>("index_name")
                                                    select pk).Any(),
                                    ColumnName,
									FieldName = "_"+ ColumnName,
                                    DataType,
                                    Length,
                                    Precision,
                                    Scale,
									IsNullable,
                                    ClrType = OracleType2Clr(enumTypeMap,tableColumns.Key, ColumnName, IsNullable, DataType, Length, Precision, Scale),
									DbType = OracleType2OracleDbType(DataType, Length, Precision, Scale)
                                 }).ToList()
                 }).ToList();
	Type enumType=null;
	foreach(var table in tables){
		var primaryKeyColumns = from column in table.Columns
								where column.IsPrimaryKey
								select column;
#>
	[Serializable]
	[DebuggerDisplay("<#= string.Join(", ", (primaryKeyColumns.Any() ? from pk in primaryKeyColumns select pk.ColumnName : (from c in table.Columns where !c.IsNullable select c.ColumnName).Take(4)).Select(c => "{" + c + ",nq}")) #>")]
	public sealed partial class <#= table.EntityName #> : DbEntity, IEquatable<<#= table.EntityName #>> {
<#  

if(primaryKeyColumns.Any()){ #>
		#region Methods
		public bool Equals(<#= table.EntityName #> other) {
			if (other == null) return false;
            return <#= string.Join(" && ", from pk in primaryKeyColumns select string.Format("{0} == other.{0}",pk.FieldName)) #>;
        }
		
		public override bool Equals(object obj) {
			return Equals(obj as <#= table.EntityName #>);
        }
		
		public override int GetHashCode() {
            return <#= string.Join(" ^ ", from pk in primaryKeyColumns select string.Format("{0}.GetHashCode()",pk.FieldName)) #>;
        }
		#endregion
<# 
}else{
#>	
		bool IEquatable<<#= table.EntityName #>>.Equals(<#= table.EntityName #> other) {
			return this.Equals(other);
        }
<# 
}

foreach(var column in table.Columns){
	string clrType = GetFriendlyName(column.ClrType);
	enumTypeMap.TryGetValue(table.EntityName + "." + column.ColumnName, out enumType);
	if(column.ClrType == typeof(byte[]))
		continue;
#>
		#region <#= column.ColumnName #>
		<#= clrType #> <#= column.FieldName #>;
        partial void On_<#= column.ColumnName #>_Changed();
		[Column(Size=<#= column.Length #>, DbType=OracleDbType.<#= column.DbType #><#= column.IsPrimaryKey?", IsPrimarykey = true":""#><#= column.IsNullable?", IsNullable = true":"" #>)]
    	public <#= clrType #> <#= column.ColumnName #> { 
			get{ return <#= column.FieldName #>; }
			set{
				if (<#= column.FieldName #> != value){
					//BeforeColumnChange("<#= column.ColumnName #>");
					<#= column.FieldName #> = value;   
                  	On_<#= column.ColumnName #>_Changed();
              	}
			}
		}
		#endregion
<# 
}#>
		#region Columns
		public sealed class Columns {		
<# 
foreach(var column in table.Columns){
	if(column.ClrType == typeof(byte[]))
		continue;
	string clrType = ToQueryTypeString(column.ClrType);
#>
    		public <#= clrType #> <#= column.ColumnName #> { get; private set; }
<# 
}
#>
		}
		#endregion
	}
	
<#
	}
}
}
#>
}
<#+ 


bool IsEnumType(Dictionary<string,Type> enumTypeMap,string tableName,string columnName){
	return enumTypeMap.ContainsKey(tableName + "." + columnName);
}

string ToQueryTypeString(Type t){
    if (t == typeof(string))
              return "DbString";
            Type nonNullable = Nullable.GetUnderlyingType(t);
            if (nonNullable != null)
            {
                if (nonNullable.IsEnum)
                    return "NullableEnum<"+ nonNullable.FullName +">";
                if (nonNullable == typeof(DateTime))
                    return "NullableDbDateTime";
                if (nonNullable == typeof(char))
                    return  "NullableDbChar";
                if (nonNullable == typeof(short))
                    return "NullableDbNumber";
                if (nonNullable == typeof(int))
                    return "NullableDbNumber";
                if (nonNullable == typeof(long))
                    return "NullableDbNumber";
                if (nonNullable == typeof(float))
                    return "NullableDbNumber";
                if (nonNullable == typeof(double))
                    return "NullableDbNumber";
                if (nonNullable == typeof(decimal))
                    return "NullableDbNumber";
            }
            else
            {
                if (t.IsEnum)
                    return "Enum<"+ t.FullName+">";
                if (t == typeof(System.DateTime))
                    return "DbDateTime";
                if (t == typeof(char))
                    return "DbChar";
                if (t == typeof(short))
                    return "DbNumber";
                if (t == typeof(int))
                    return "DbNumber";
                if (t == typeof(long))
                    return "DbNumber";
                if (t == typeof(float))
                    return "DbNumber";
                if (t == typeof(double))
                    return "DbNumber";
                if (t == typeof(decimal))
                    return "DbNumber";
            }
            throw new NotSupportedException("Data type :"+t + " is not supported");
}

Type OracleType2Clr(Dictionary<string,Type> enumTypeMap, string tableName,string columnName,bool isNullable,string oracleType,decimal length,decimal? precision,decimal? scale) {
    Console.WriteLine("{0} - {1} {2}({3},{4},{5})", tableName, columnName, oracleType, length, precision, scale);
    if (oracleType.IndexOf("CHAR") != -1) {
        Type enumType;
        if (enumTypeMap.TryGetValue(tableName + "." + columnName, out enumType))
			if(isNullable)
				return typeof(Nullable<>).MakeGenericType(enumType);
			else
            	return enumType;
        return typeof(string);
    }
	
    if (oracleType == "NUMBER" && (scale??0) ==0) {
        if(precision==null){
            if(length>18)
                return isNullable?typeof(long?):typeof(long);
            if(length>9)
                return isNullable?typeof(int?):typeof(int);
            if(length>4)
                return isNullable?typeof(short?):typeof(short);
        }else{
			if(precision >=19)
				return isNullable ? typeof(decimal?) : typeof(decimal);
			if(precision >=10)
				return isNullable ? typeof(long?) : typeof(long);
			if(precision >=6)
				return isNullable ? typeof(int?) : typeof(int);
			return isNullable ? typeof(short?) : typeof(short);
        }
        return isNullable ? typeof(decimal?) : typeof(decimal);
    }
	
    if (oracleType == "DATE" || oracleType.StartsWith("TIMESTAMP"))
       	return isNullable ? typeof(DateTime?) : typeof(DateTime);
	
	if (oracleType == "FLOAT")
    {
        if (precision > 23)
			return isNullable ? typeof(double?) : typeof(double);
        return isNullable ? typeof(float?) : typeof(float);
    }

    if(oracleType == "BLOB")
		return typeof(byte[]);
    
	throw new ApplicationException(tableName+","+columnName+" Unknown type " + oracleType);
}

OracleDbType OracleType2OracleDbType(string oracleType, decimal length, decimal? precision, decimal? scale) {
            if (oracleType == "CHAR")
                return OracleDbType.Char;

            if (oracleType == "NCHAR")
                return OracleDbType.NChar;

            if (oracleType == "NVARCHAR2")
                return OracleDbType.NVarchar2;

            if (oracleType == "VARCHAR2")
                return OracleDbType.Varchar2;

            if (oracleType == "NUMBER" && (scale??0) ==0) {
                if (precision == null) {
                    if (length > 18)
                        return OracleDbType.Int64;
                    if (length > 9)
                        return OracleDbType.Int32;
                    if (length > 4)
                        return OracleDbType.Int16;
                    return OracleDbType.Byte;
                }else{
                    if(precision >=19)
						return OracleDbType.Decimal;
					if(precision >=10)
						return OracleDbType.Int64;
					if(precision >=6)
						return OracleDbType.Int32;
					return OracleDbType.Int16;
                }
                return OracleDbType.Decimal;
            }

            if (oracleType == "DATE")
                return OracleDbType.Date;

            if (oracleType.StartsWith("TIMESTAMP"))
                return OracleDbType.TimeStamp;

            if (oracleType == "FLOAT")
            {
                if (precision > 23)
                    return OracleDbType.Double;
                return OracleDbType.Single;
            }
                
            if(oracleType == "BLOB")
				return OracleDbType.Blob;
            throw new ApplicationException(" Unknown type " + oracleType);
}

Type GetNonNullType(Type t)
{
            if (t.IsGenericType && t.GetGenericTypeDefinition() == (typeof(Nullable<>)))
                return t.GetGenericArguments()[0];
            return t;
}

string GetFriendlyName(Type t)
{
            using (var provider = new CSharpCodeProvider())
            {
                var typeRef = new CodeTypeReference(t);
                return provider.GetTypeOutput(typeRef);
            }
}
#>